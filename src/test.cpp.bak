#include "libfreenect.hpp"
#include <iostream>
#include <vector>
#include <cmath>
#include <pthread.h>
#include <cv.h>
#include <cxcore.h>
#include <highgui.h>

using namespace cv;
using namespace std;

class Mutex {
public:
	Mutex() {
		pthread_mutex_init( &m_mutex, NULL );
	}
	void lock() {
		pthread_mutex_lock( &m_mutex );
	}
	void unlock() {
		pthread_mutex_unlock( &m_mutex );
	}
private:
	pthread_mutex_t m_mutex;
};

class KinecapDevice : public Freenect::FreenectDevice {
public:
	KinecapDevice(freenect_context *_ctx, int _index)
	: Freenect::FreenectDevice(_ctx, _index)
	{
	}
	// Do not call directly even in child
	void VideoCallback(void* _rgb, uint32_t timestamp) {
		//std::cout << "RGB callback" << std::endl;
		m_rgb_mutex.lock();
		uint8_t* rgb = static_cast<uint8_t*>(_rgb);

		cvSetData(mRgbImg,rgb,640*3);
		cvtColor(mRgbImg,mRgbImg,CV_RGB2BGR);
		m_rgb_mutex.unlock();
	};
	// Do not call directly even in child
	void DepthCallback(void* _depth, uint32_t timestamp) {
		// std::cout << "Depth callback" << std::endl;
		m_depth_mutex.lock();
		uint16_t* depth = static_cast<uint16_t*>(_depth);
		cvSetData(mDepthImg,depth,640*2);
		m_depth_mutex.unlock();
	}



	void registerRGBImage(IplImage *rgbImg)
	{
		m_rgb_mutex.lock();
		mRgbImg = rgbImg;
		m_rgb_mutex.unlock();
	}
	void registerDepthImage(IplImage *depthImg)
	{
		m_depth_mutex.lock();
		mDepthImg = depthImg;
		m_depth_mutex.unlock();
	}

private:
	IplImage* mRgbImg;
	IplImage* mDepthImg;
	Mutex m_rgb_mutex;
	Mutex m_depth_mutex;
};

class Histogram
{
public:
	Histogram()
	{

		// Build and fill the histogram

		int scale = 10;
		int h_bins = 30, s_bins = 32;
		{
			int hist_size[] = { h_bins, s_bins };
			float h_ranges[] = { 0, 180 };
			float s_ranges[] = { 0, 255 };
			float* ranges[] = { h_ranges, s_ranges };
			hist = cvCreateHist( 1, hist_size, CV_HIST_ARRAY, ranges, 1 );
		}

		// Create an image to visualize the histogram
		hist_img = cvCreateImage( cvSize( h_bins * scale, s_bins * scale ), 8, 3 );
		cvZero ( hist_img );



		// Show histogram equalized
		cvNamedWindow( "H-S Histogram", 1) ;


	}

	void Update(IplImage* planes[], IplImage* back_img)
	{
		int h_bins = 30, s_bins = 32;
		int scale = 10;

		cvCalcHist( planes, hist, 0, 0 ); // Compute histogram
		cvNormalizeHist( hist, 20*255 ); // Normalize it

		cvCalcBackProject( planes, back_img, hist );// Calculate back projection
		cvNormalizeHist( hist, 1.0 ); // Normalize it

		//crit = ( cv.CV_TERMCRIT_EPS | cv.CV_TERMCRIT_ITER, 10, 1)

		// populate the visualization
		float max_value = 0;
		cvGetMinMaxHistValue( hist, 0, &max_value, 0, 0 );

		for( int h = 0; h < h_bins; h++ ){
			for( int s = 0; s < s_bins; s++ ){
				float bin_val = cvQueryHistValue_2D( hist, h, s );
				int intensity = cvRound( bin_val * 255 / max_value );
				cvRectangle( hist_img, cvPoint( h*scale, s*scale ),
						cvPoint( (h+1)*scale - 1, (s+1)*scale - 1 ),
						CV_RGB( intensity, intensity, intensity ),
						CV_FILLED );
			}
		}
	}

	void Render()
	{

		cvShowImage( "H-S Histogram", hist_img );

	}

	~Histogram()
	{
		cvReleaseImage( &hist_img );
	}
	IplImage* hist_img;
	CvHistogram* hist;

};


void DoCamShift()
{


}

#include "cv.h"
#include "highgui.h"
#include <stdio.h>
#include "capture.h"
#include "facedet.h"
#include "camshift_wrapper.h"

#define OPENCV_ROOT  "/home/fcoulombe/src/opencv"

IplImage  * pVideoFrameCopy = 0;
void captureVideoFrame(IplImage  * pVideoFrame)
{

	// Copy it to the display image, inverting it if needed
	if( !pVideoFrameCopy )
		pVideoFrameCopy = cvCreateImage( cvGetSize(pVideoFrame), 8, 3 );
	/*cvCopy( pVideoFrame, pVideoFrameCopy, 0 );
	pVideoFrameCopy->origin = pVideoFrame->origin;

	if( 1 == pVideoFrameCopy->origin ) // 1 means the image is inverted
	{
		std::cout << "flip" << std::endl;
		cvFlip( pVideoFrameCopy, 0, 0 );
		pVideoFrameCopy->origin = 0;
	}*/
}
int main(int argc, char **argv) {
	bool die(false);

	//Mat depthMat(Size(640,480),CV_16UC1);
	//Mat rgbMat(Size(640,480),CV_8UC3,Scalar(0));

	IplImage* rgbImg = cvCreateImageHeader(cvSize(640,480), IPL_DEPTH_8U, 3);
	IplImage* depthImg = cvCreateImageHeader(cvSize(640,480), IPL_DEPTH_16U, 1);

	Freenect::Freenect freenect;
	KinecapDevice& device = freenect.createDevice<KinecapDevice>(0);

	device.registerRGBImage(rgbImg);
	device.registerDepthImage(depthImg);
	device.startVideo();
	device.startDepth();


	namedWindow("rgb",CV_WINDOW_AUTOSIZE);
	namedWindow("depth",CV_WINDOW_AUTOSIZE);


	CvRect * pFaceRect = 0;
	//if( !initCapture() ) return 0;
	if( !initFaceDet(OPENCV_ROOT "/data/haarcascades/haarcascade_frontalface_default.xml"))
		return 0;



	enum State
	{
		FIRST_RUN,
		FACE_DETECTION,
		TRACKING
	};

	State state =FIRST_RUN;
	while (!die) {
		switch (state)
		{
		case FIRST_RUN:
			std::cout << "Initializing"<<std::endl;
			// Initialize tracker
			captureVideoFrame(rgbImg);
			/*if( !createTracker(pVideoFrameCopy) )
        		return 0;
        	// Set Camshift parameters
        	setVmin(60);
        	setSmin(50);*/
			state = FACE_DETECTION;
			std::cout << "Detecting face"<<std::endl;
			break;
		case FACE_DETECTION:

			// Look for a face in the next video frame
			captureVideoFrame(rgbImg);
			/*pFaceRect = detectFace(pVideoFrameCopy);*/

			// Show the display image
			//cvShowImage( "rgb", pVideoFrameCopy );
			/*if( (char)27==cvWaitKey(1) )
    			return 0;

    		// exit loop when a face is detected
    		if(pFaceRect)*/
			{
				// initialize tracking
				//startTracking(pVideoFrameCopy, pFaceRect);
				state = TRACKING;
				std::cout << "Tracking..."<<std::endl;
			}
			break;
		case TRACKING:
			CvBox2D faceBox;

			static int j =0;
			std::cout << "track" << j++ << std::endl;
			// get the next video frame
			captureVideoFrame(rgbImg);

			/*// track the face in the new video frame
    		faceBox = track(pVideoFrameCopy);

    		// outline face ellipse
    		cvEllipseBox(pVideoFrameCopy, faceBox,
    		             CV_RGB(255,0,0), 3, CV_AA, 0 );
    		cvShowImage( "rgb", pVideoFrameCopy );*/
			cvShowImage( "rgb", rgbImg);
			if( (char)27==cvWaitKey(1) ) break;

		}
		sleep(0);

	}

	cvReleaseImageHeader(&rgbImg);

	device.stopVideo();
	device.stopDepth();
	return 0;
}
/*
int main(int argc, char **argv) {
    bool die(false);
    string filename("snapshot");
    string suffix(".png");
    int i_snap(0),iter(0);

    Mat depthMat(Size(640,480),CV_16UC1);
    Mat depthf  (Size(640,480),CV_8UC1);
    Mat rgbMat(Size(640,480),CV_8UC3,Scalar(0));
    Mat ownMat(Size(640,480),CV_8UC3,Scalar(0));

    Freenect::Freenect freenect;
    MyFreenectDevice& device = freenect.createDevice<MyFreenectDevice>(0);

    namedWindow("rgb",CV_WINDOW_AUTOSIZE);
    namedWindow("depth",CV_WINDOW_AUTOSIZE);
    namedWindow( "back", CV_WINDOW_AUTOSIZE) ;
    device.startVideo();
    device.startDepth();

    IplImage* rgbImg = cvCreateImageHeader(cvSize(640,480), IPL_DEPTH_8U, 3);
    IplImage* hsvImg = cvCreateImage( cvGetSize(rgbImg), IPL_DEPTH_8U, 3 );
    IplImage* back_img = cvCreateImage( cvGetSize( rgbImg ), IPL_DEPTH_8U, 1 );

    IplImage* h_plane = cvCreateImage( cvGetSize( rgbImg ), 8, 1 );
    IplImage* s_plane = cvCreateImage( cvGetSize( rgbImg ), 8, 1 );
    IplImage* v_plane = cvCreateImage( cvGetSize( rgbImg ), 8, 1 );

    IplImage* planes[] = { h_plane , s_plane };

    Histogram hist;
    while (!die) {
        device.getVideo(rgbMat);
        device.getDepth(depthMat);

        cvSetData(rgbImg,rgbMat.data,640*3);
        cvCvtColor( rgbImg, hsvImg, CV_BGR2HSV );

        cvCvtPixToPlane( hsvImg, h_plane, s_plane, v_plane, 0 );

        hist.Update(planes, back_img);


        hist.Render();

        cvShowImage("back", back_img);
        cvShowImage("rgb", rgbImg);

        //cv::imshow("rgb", rgbMat);

        depthMat.convertTo(depthf, CV_8UC1, 255.0/2048.0);
        cv::imshow("depth",depthf);

        char k = cvWaitKey(5);
        if( k == 27 ){
            cvDestroyWindow("rgb");
            cvDestroyWindow("depth");
            break;
        }
        if( k == 8 ) {
            std::ostringstream file;
            file << filename << i_snap << suffix;
            cv::imwrite(file.str(),rgbMat);
            i_snap++;
        }
        if(iter >= 1000) break;
        iter++;
    }

    cvReleaseImageHeader(&rgbImg);
    cvReleaseImageHeader(&hsvImg);

    device.stopVideo();
    device.stopDepth();
    return 0;
}

 */
